# C++总结：

1.const 和static作用，voliate？

const 对象为只读类型，表示不可修改。

static 全局区静态区，表示对象在编译期分配内存空间，作用为隐藏和保持。修饰全局变量对外部文件不可见，修饰局部变量相当于延长了生命周期，因为本来局部变量在栈内，调用结束就被销毁，加了static后位于全局区，等程序运行结束才被释放。

static修饰类成员，static成员函数只能调用static成员变量。static成员为属于该类所有实例对象共享。

voliate：和const相对，变量为易变的不稳定的，不让编译器优化变量值。每次取值从内存中获取。

2.new和malloc区别：

new是c++关键字，malloc是库函数（头文件stdlib.h或memory.h）new 无需指定内存大小，new会调用构造函数，失败返回bad_allocate；malloc需要显式指定内存大小，失败返回空指针。

3.malloc底层实现：

https://blog.csdn.net/z_ryan/article/details/79950737

linux系统向用户提供申请的内存有brk(sbrk)和mmap函数。

```c++
#include <unistd.h>
int brk( const void *addr )
void* sbrk ( intptr_t incr );
两者的作用是扩展heap的上界brk
Brk（）的参数设置为新的brk上界地址，成功返回1，失败返回0；
Sbrk（）的参数为申请内存的大小，返回heap新的上界brk的地址
```

```c++
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
mmap的第一种用法是映射此盘文件到内存中；第二种用法是匿名映射，不映射磁盘文件，而向映射区申请一块内存。
malloc使用的是mmap的第二种用法（匿名映射）。
munmap函数用于释放内存。
```

因为brk、sbrk、mmap都属于系统调用，若每次申请内存，都调用这三个，那么每次都会产生系统调用，影响性能；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果高地址的内存没有被释放，低地址的内存就不能被回收。所以malloc采用的是内存池的管理方式（ptmalloc），Ptmalloc 采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。为了内存分配函数malloc的高效性，ptmalloc会预先向操作系统申请一块内存供用户使用，当我们申请和释放内存的时候，ptmalloc会将这些内存管理起来，并通过一些策略来判断是否将其回收给操作系统。这样做的最大好处就是，使用户申请和释放内存的时候更加高效，避免产生过多的内存碎片。（malloc一定会产生系统调用吗？不一定，有个阈值...待）

4.1G内存计算机能否malloc(1.2G)？为什么？

不能，程序执行过程中实际内存有预留给内核空间，分配给进程空间大小小于1G。

4.指针和引用区别和相同点？如何相互转换？

指针可指向为空，引用不可用为空。指针可在任何时间初始化，引用必须创建时初始化。一旦引用被初始化，就不能改变引用关系，指针可随时改变指向对象。引用相当于对象的别名。

互相转换：将指针用*转换为对象，即可用于引用参数中；把引用类型的对象用&就可获得指针。

注：有常量指针，指针常量，常量引用，没有引用常量。

- 左值和右值？左值引用和右值引用？
- 左值：lvalue(locatevalue可被定位寻址的值)生命周期长，右值（rvalue）生命周期短（寄存器临时变量）
- 左值引用：type & xxx= x变量名；别名。右值引用 type&& xxx= 变量值；

5.const_cast()，static_cast()，dynmic_cast()，reinterpret_cast()类型转换总结？

 c语言强制类型转换主要用于基础的数据类型间的转换，语法为：

```
(type-id)expression//转换格式1

type-id(expression)//转换格式2
```

c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化，语法为：

```c++
static_cast<new_type>      (expression)
dynamic_cast<new_type>     (expression) 
const_cast<new_type>       (expression) 
reinterpret_cast<new_type> (expression)
```

(1)const_cast()取消对象的const,voliate等属性，可用常量初始化常引用，但不能常量初始化普通引用。

(2)static_cast()基本类型转换，例：int->float，但不能用于不同基本类型指针间转换；可用于有继承关系的类之间对象间（父类对象和子类对象）的转换和父类子类指针间转换，但不安全，有可能父类中无子类某些方法。

(3)dynmic_cast()用于有继承关系的基类和派生类指针之间的转换，前提是必须有多态存在，向上转型：基类指针对象=派生类指针对象，向下转型：派生类指针对象=基类指针对象。如果转换目标为指针类型转换失败，结果返回0，若转换引用类型失败将抛出std::bad_cast

(4)reinterpret_cast()用于普通类型间转换，但不安全，用于整数与指针间转换。

6.可执行程序内存分配情况（存储时和运行时）？栈和堆区别？

命令size xxx可输出下列：

text （代码区）：存放cpu执行的机器指令，通常代码区是可共享的，代码区通常为只读的，原因防止程序意外修改指令，另外代码区还规划了局部变量的相关信息。

data（初始化全局区/静态数据区）：包含在程序中明确被初始化的全局变量，静态变量（全局和局部静态变量）与常量数据（如字符串常量）。

bss（未初始化数据区） ：来源于早期汇编运算符，这个汇编运算符标志一个块的开始，BSS的数据在程序开始执行之前被内核初始化为0或空指针NULL。		

dec（十进制总和）hex（十六进制总和）filename（文件名）

<img src="https://img-blog.csdn.net/20160109091951857" alt="这里写图片描述" style="zoom: 67%;" />

运行时多了栈区和堆区：

栈区（stack）：由高地址向低地址扩展。由编译器自动分配和释放，存放函数的参数值，局部变量的值等。操作方式类似于栈结构，当每一个函数被调用时，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后被调用的函数再为它的自动变量和临时变量在栈区上分配空间，即C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈变量混淆。

堆区（heap）：程序员手动分配与释放。用于动态内存分配，堆区在内存中位于bss区和栈区之间。若程序员不释放，程序结束时有可能被OS回收。

7.extern "C"作用？

在C++程序中代码按照C语言方式编译。按照C++中支持函数重载，编译器编译函数过程中会将函数的参数类型也加到编译后的代码中，而不仅仅时函数名；因为C语言中没有重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

主要使用在：（1）C++代码调用C语言代码，（2）在C++头文件使用，（3）多人协同开发时有的人擅长C语言，有的人擅长C++。

8.函数参数压栈顺序？

对于常见的C++程序，缺省 __ cdecl或使用 __ stdcall的函数压栈顺序都是采用从右往左压栈， __ pascall从左往右压栈。

__ stdcall堆栈由函数本身清理，__cdecl由调用者清理。

9.重写memcpy函数注意问题？

原型：void * memcpy(void *dst,const void * src, size_t n)

注释：//If copying takes place between objects that overlap, the behavior is undefined.

陷阱：（1）不能对void类型指针进行如p++操作，需要转换为具体类型指针如char*操作。

（2）对于地址重叠的情况，该函数的行为是未定义的。手动实现memcpy时需要考虑地址重叠的问题。

10.数组存放在哪？

情况（1）char *p="abcde" p在栈，字符串在数据区。p[2]='w'，报错p指向常量数据区，不能修改其置值。

情况（2）char s[]="abcde" s在栈，字符串在数据区，s[2]='w'，正确，s是一个数组，分配栈上内存，而情况1是一个指针没有申请内存。

```c++
int a = 0; 全局初始化区 
char *p1; 全局未初始化区 
main() 
{ 
int  b; 栈 
char s[] = "abc"; 栈 
char *p2; 栈 
char *p3 = "123456"; 123456\0在常量区，p3在栈上。 
static int c =0； 全局（静态）初始化区 
p1 = (char *)malloc(10); 
p2 = (char*)malloc(20); 
分配得来得10和20字节的区域就在堆区。 
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
} 
申请方式  
stack:  
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间  
heap:  
需要程序员自己申请，并指明大小，在c中malloc函数  
如p1 = (char *)malloc(10);  
在C++中用new运算符  
如p2 = new char[10];  
但是注意p1、p2本身是在栈中的。  
```

11.struct和class区别？

最大的区别在于默认成员访问限定符，struct默认为public，class默认为private。struct偏向描述数据，class偏向描述数据和方法结合体。struct 不支持模板操作。struct 默认继承为public，class为private。

12.char 和 int转换？

长字节转短字节产生截断，若默认有符号位转换时，符号位也被当做有效数字。

char转int ，有符号转换时高位为1补0xffffff三字节。高位0补0x000000.

13.const和#define区别？编译阶段，安全性，内存占用情况？

const 有类型检查，更为安全。#define仅仅预编译阶段为文本替换，无法进行调试，编译期无类型检查。可用于实现静态多态。占用空间：#define PI 3.14 预处理，占用代码段空间，const float PI=3.14本质上还是一个 float占用数据段空间。

const不能重定义，#define可以通过#undef取消定义再重新定义。

#define可防止头文件重复引用，而const不能。

- 继承和多态相关：

14.虚继承：

解决多继承中菱形继承时命名冲突，编译器不知道继承自哪个基类从而报错问题。C++提出虚继承，使得派生类中只保留一份间接基类的成员。参考：http://c.biancheng.net/view/2280.html

<img src="http://c.biancheng.net/uploads/allimg/200629/1-2006291J3551E.png" alt="菱形继承和虚继承" style="zoom:67%;" />

```c++
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

15.多态类内存布局？

https://blog.csdn.net/songguangfan/article/details/87898915

C++中 的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术 可以让父类的指针有“多种形态”，这是一种泛型技术。

- 虚函数表

每个含有虚函数的类都有一个虚函数表（Virtual Table）来实现的。简称为V-Table。 C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

1、  每一个类都有虚函数列表。

2、  虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。

3、  派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同，子类独有的虚函数放在后面。

 当定义一个有虚函数类的对象时，对象的第一块的内存空间就是一个指向虚函数列表的指针。

<img src="https://img-blog.csdnimg.cn/20190224001223132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbmdndWFuZ2Zhbg==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

16.被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量？

（1）当子类中含有和基类同名成员变量时，再用子类的对象调用该成员变量时，将会只调用到子类自身的成员变量，子类把基类同名成员隐藏了。

（2）子类中含有基类同名成员函数时，再用子类的对象调用该同名成员函数时，只会调用子类自身定义的成员函数，子类把基类同名成员函数隐藏了。注意：只要同名，无论参数是否相同，返回值是否相同，只要函数名相同即为同名成员函数。

17.多态实现的三个条件？

（1）要有继承（2）父对象引用子类对象（或函数指针引用）（3）要有方法重写(virtual)

- 类访问权限区别？
- public:本类，派生类，类对象实例均可访问；
- private:只能本类和友元访问；
- protected：本类，友元，以及派生类访问；

18.拷贝构造函数的深浅拷贝理解？拷贝构造函数的用途？什么时候需要自定义拷贝构造函数？

没有拷贝构造函数的类系统创建默认的拷贝构造函数（浅拷贝，指针指向旧对象同一内存）调用默认拷贝构造函数，对象指针指向旧的对象，不为新对象中的指针成员分配空间。

深拷贝不但对指针进行拷贝，而且对指针指向内容进行拷贝，深拷贝后的指针指向和源对象内存不同。

为什么需要自定义拷贝构造函数和析构函数？-》对于拷贝构造函数造成两个对象指向同一内存后，当删除其中一个对象后导致另一对象指向为空，此时就需要自定义拷贝构造函数进行深拷贝。当类的数据成员中使用了动态分配的内存，就需要字节定义析构函数释放该部分内存，防止内存泄漏。总结：有指针数据成员的类必须自己定义析构函数。

19.析构函数可以抛出异常吗？构造函数可以抛出异常吗？为什么？

析构函数不可以，构造函数可以。

c++中抛出异常用 throw 表达式；通常在异常点之后的程序不会执行下去，为了安全考虑，析构函数不要抛出异常，析构函数是为了释放对象资源，若析构过程出现异常，不能保证对象资源的释放，可能导致内存泄漏。异常发生时其会调用已经创建对象的析构函数释放资源，若析构函数本身抛出异常，前一个异常尚未处理，又有了新的异常，会导致程序崩溃。

解决方法：将异常完全封装在析构函数内部，不让异常抛出析构函数之外。

20.什么情况会调用拷贝构造函数？

（1）用类的一个对象去初始化另一个对象

（2）当函数的形参是类的对象时（即值传递时），如果时引用传递则不会调用

（3）当函数的返回值是类的对象或引用

21.析构函数为虚函数原因？构造函数不能为虚函数原因？

C++内部的编译器会把析构函数的名自动更改和设定的，所以编译器看到的析构函数名其实是同样的

（1）用派生类类型指针绑定派生类实例，析构时不管基析构函数是否为虚函数都会正常析构

（2）用基类类型指针绑定派生类实例，析构时，若基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。

构造函数不能为虚函数：因为类的虚函数表指针是在构造函数中初始化的，若构造函数本身就是虚函数，哪谁来初始化它的虚函数指针呢？构造函数和析构函数中也不能调用虚函数，调用了也没有，一个是虚函数表指针还没初始化好，一个是虚函数指针可能已经被析构了。

22.什么是纯虚函数？什么是抽象类？

纯虚函数只有定义没有实现。即只定义了接口=0，没有代码实现部分。

virtual void fun()=0;

含有纯虚函数的类叫虚基类，这种基类不能直接生成对象（即不能实例化），只有被继承，并且重写虚函数后才能使用。也叫抽象类。

23.静态绑定和动态绑定介绍？

C++面向对象编程中，存在静态绑定和动态绑定定义。

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

24.C++中所有的构造函数？

（1）默认构造函数（无参数）

（2）一般构造函数（有参数），普通变量等。

（3）拷贝构造函数（参数为类对象本身的引用），参数（对象的引用）是不可变的（const类型），常用于函数调用时用户定义类型的值传递及返回。

25.重写、重载、隐藏的区别？

重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

重载：同一作用域内声明几个具有不同参数列表（参数类型，个数，顺序）的同名函数，调用时自动根据参数列表确定调用哪个函数，和返回值类型无关。

隐藏：派生类隐蔽了基类同名函数。（无论参数列表，返回值是否相同）

26.成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？

在类构造函数中，不再函数花括号体内进行变量赋值，而在参数列表后，跟一个冒号和初始化列表。

效率更高原因：对于非内置类型，少了一次调用默认构造函数的过程。

 effective C++ 条款4：确定对象被使用前已先被初始化。 第28页：对象成员变量的初始化动作发生在进入构造函数之前。当然对于内置类型没什么影响，但如果有些成员是类，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以是一次默认构造加一次赋值

27.如何避免编译器进行隐式类型转换？

c++ 中的 explicit 关键字只能用于修饰只有一个参数的类构造函数，即作用为：禁止隐式调用类内的单参数构造函数。

1. 该关键字只能用来修饰类内部的构造函数；
2. 禁止隐式调用拷贝构造函数；
3. 禁止类对象之间的隐式转换；

```c++
class Test{
	explicit Test(int a);
}
Test aa(10); //ok
Test aa=10;	//非法
Test bb=aa;	//非法取消了隐式转换除非重载操作符”=“
```

28.什么类不能被继承？

首先考虑派生类继承基类会发生什么操作。派生类调用自身的构造函数之前需要调用基类的构造函数。那么阻止该步骤有三种方式：

（1）将基类构造函数与析构函数放在private域内；

（2）将基类作为一个已存在类的友元类；

利用了友元不能被继承的特征。

```c++
class CPre{
    friend class CBase;
private:
	CPre(){}
    ~CPre(){}
};
class CBase :virtual public CPre{
public:
    CBase(){}
	~CBase(){}
};
class CChild: public CBase{
public:
    CChild(){}	//编译报错
    ~CChild(){}	//编译报错
};
```

（3）使用C++新特性final关键字：

```c++
class CBase final{

};
```

29.静态成员变量，静态成员函数介绍？

类的静态成员变量声明为static 时，与一般成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。

静态成员变量在编译期就分配了空间，对象还没创建时就分配了空间，放在全局静态区。

静态成员变量：

- 最好类内声明，类外初始化（以免通过类名访问静态成员访问不到，静态成员变量数据类内初始化时必须用const修饰：static const int xxx
- 无论公有，私有，静态成员都可以在类外定义，但私有成员仍具有访问权限
- 非静态成员不能在类外初始化
- 静态成员数据是共享的（该类和所有实体对象）

静态成员函数：

- 静态成员函数可以直接访问静态成员变量，不能访问普通成员变量，但可以通过参数传递方式访问。
- 普通成员函数可以访问普通成员变量，也可以访问静态成员变量
- 静态成员函数没有this指针（this指针指向调用函数的对象）。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区别哪个是对象，因此不能直接访问普通变量成员，也没有this指针。

30.mmap函数简介？有关文件高级读写提升速度相关的API？

用于将一个文件或其他对象映射到内存中，提供文件访问速度。

函数签名：

```c++
#include<mman.h>
void * mmap(void* start,size_t length,int prot,int flag,int fd,off_t offset);
int munmap(void* start,size_t length);
参数说明：
start:映射开始地址，设置为0表示由系统决定映射区起始地址
length：映射区长度
prot：期望的内存保护标志，不能与文件的打开模式冲突，可用 stat函数获取文件权限和大小信息。PROT_READ表示页内容可以被读取
flags：直到映射对象的类型，映射选项和映射页是否可以共享，MAP_PRIVATE建立一个写入时拷贝的私有映射，内存区域的写入不会影响到源文件
fd：有效的文件描述符，一般由open()函数返回
off_t offset：被映射对象内容的起点
```

- readv和writev函数

```c++
ssize_t readv(int fd,const struct iovec* iov,int iovcnt);
ssize_t writev(int fd,const struct iovec* iov,int iovcnt);
fd:要在其上面进行读或者写的文件描述符
iov：读或写所用的IO向量（数组）
iovcnt表示使用向量元素的个数
返回值，readv或writev字节数，错误返回-1，并设置errno
```

- 注意：一般在服务器写数据时，往往循环调用writev时，需要重写处理iovec中的指针和长度，该函数不会对这两个成员做任何处理，因为传入参数为iovec数组，计量单位是iovcnt，而不是字节数，任然需要通过遍历iovec计算新的基址，另外写入数据的结束点可能位于一个iovec的中间某个位置，因此需要调整临界iovec的io_base和io_len。

```c++
readv和writev函数用于在一次函数调用中读，写多个非连续的缓冲区，有时也将
其成为散布读（scatter read）和聚集写（gather write）
#include<uio.h>
struct iovec{
	void *iov_base;//指向缓冲区，存放readv所接收的数据或writev将要发生的数据
	size_t iov_len;//确定了最大长度以及实际写入的长度
};


```

31. C++类的指针调用成员函数问题？成员变量初始问题？

```c++
#include<iostream>
#include<vector>
using namespace std;


class Base {
public:
	virtual void funB() {
		cout << "Base funB" << endl;
	}
	void funC() {
		cout << "Base funC" << endl;
	}
};

class Derived : public Base{
public:
	void funB() {
		cout << "Derived funB" << endl;
	}
	virtual void funC() {
		cout << "Derived funC" << endl;
	}
	void funD() {
		cout << "Derived funD" << endl;
	}

};

int main() {

    //派生类继承基类虚函数指针和虚函数表
    //是哪个类的指针就调用哪个类的方法，子类重写虚函数则调用子类方法
	Base * p = new Derived;
	p->funB();
	p->funC();

	Derived * q = new Derived;
	q->funB();
	q->funC();
	q->funD();
	
	Base r;
	r.funB();
	Derived n;
	n.funC();
    
	return 0;
}

输出：
Derived funB
Base funC
Derived funB
Derived funC
Derived funD
Base funB
Derived funC
```

32.智能指针？(RAII机制，资源获取即初始化)

shared_ptr：模板类。（强引用，增加引用计数），一个对象可以有多个共享智能指针，当这个对象的所有智能指针被销毁时就会自动进行回收。（内部使用引用计数机制）但是会存在循环引用时，资源无法释放。（A->B,B->A）

weak_ptr：配合shared_ptr使用，不能单独使用，解决循环引用问题，弱引用，不增加引用计数。防止出现死锁。

unique_ptr：auto_ptr的改进版。不能赋值也不能拷贝，保证一个对象同一时间只能有一个智能指针。

33.函数调用过程？

（1）从栈分配空间；（2）从实参的存储空间复制值到参数栈空间；(3)进行运算。

34.string类底层实现？

继承自basic_string，对char*进行了封装，封装的string包含char * 数组，容量，长度等属性，可动态扩展，每次扩展时申请另一块元空间大小两倍で空间（2*n），然后将原字符串拷贝过去，并增加新的内容。

35.free掉的内存是立即返还给操作系统吗？

不是，被free回收的内存会被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的内存返回，避免了频繁で系统调用，占用过多系统资源。同时ptmalloc尝试对小块内存合并，避免过多内存碎片。
